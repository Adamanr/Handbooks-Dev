package handlers

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"handbooks/internal/api"
	"handbooks/internal/config"
	"log/slog"
	"net/http"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/go-chi/cors"
	"github.com/golang-jwt/jwt/v5"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/redis/go-redis/v9"
	"github.com/rs/xid"
	slogchi "github.com/samber/slog-chi"
)

type ctxKey string
type ResponseOption func(*responseOptions)

const (
	requestIDKey ctxKey = "X-Request-ID"
	tokenKey     ctxKey = "Authorization"
)

type Server struct {
	DB     *pgx.Conn
	Config *config.Config
	ctx    context.Context
	Redis  *redis.Client
	JwtKey []byte
}

// DeleteUserById implements [api.ServerInterface].
func (s *Server) DeleteUserById(w http.ResponseWriter, r *http.Request, userId string) {
	panic("unimplemented")
}

var _ api.ServerInterface = (*Server)(nil)

// responseOptions - –æ–ø—Ü–∏–∏ –¥–ª—è —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –æ—Ç–≤–µ—Ç–∞
type responseOptions struct {
	respType  string
	requestID string
}

// NewServer - functions for return server object
func NewServer(db *pgx.Conn, redis *redis.Client, config *config.Config) *Server {
	return &Server{
		DB:     db,
		Redis:  redis,
		ctx:    context.Background(),
		Config: config,
		JwtKey: []byte(config.JwtOpt.Key),
	}
}

// Run - functions for run http Server with settings
func (s *Server) Run() error {
	r := chi.NewMux()

	r.Use(cors.Handler(cors.Options{
		AllowedOrigins:   []string{"https://*", "http://*"},
		AllowedMethods:   []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
		AllowedHeaders:   []string{"Accept", "Authorization", "Content-Type", "X-CSRF-Token"},
		ExposedHeaders:   []string{"Link"},
		AllowCredentials: true,
		MaxAge:           300,
	}))

	r.Use(slogchi.NewWithConfig(slog.Default(), slogchi.Config{
		DefaultLevel:     slog.LevelInfo,
		ClientErrorLevel: slog.LevelWarn,  // 400‚Äì499 ‚Üí Warn
		ServerErrorLevel: slog.LevelError, // 500+   ‚Üí Error
		WithRequestID:    true,            // –±–µ—Ä—ë—Ç request-id –∏–∑ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
		Filters: []slogchi.Filter{
			slogchi.IgnorePath("/health", "/metrics", "/favicon.ico"),
		},
	}))

	r.Use(s.MiddlewareRequestID)
	r.Use(s.AuthMiddleware)

	h := api.HandlerFromMux(s, r)

	srv := &http.Server{
		Handler:      h,
		Addr:         s.Config.ServerURL(),
		ReadTimeout:  s.Config.ReadTimeout(),
		WriteTimeout: s.Config.WriteTimeout(),
		IdleTimeout:  s.Config.IdleTimeout(),
	}

	go func() {
		if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			slog.Error("HTTP —Å–µ—Ä–≤–µ—Ä —É–ø–∞–ª", "error", err)
		}
	}()

	slog.Info("–ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –∑–∞–ø—É—â–µ–Ω–æ —É—Å–ø–µ—à–Ω–æ üöÄ", slog.String("URL", s.Config.ServerURL()))

	<-s.ctx.Done()

	slog.Info("–û—Å—Ç–∞–Ω–æ–≤–∫–∞ HTTP —Å–µ—Ä–≤–µ—Ä–∞...")
	shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer shutdownCancel()

	return srv.Shutdown(shutdownCtx)
}

// === Middlewares ===

func (s *Server) AuthMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if r.URL.Path == "/auth/register" || r.URL.Path == "/auth/login" {
			next.ServeHTTP(w, r)
			return
		}

		tokenStr := r.Header.Get("Authorization")
		if tokenStr == "" {
			s.JSON(w, r, http.StatusUnauthorized, "missing token", "error")
			return
		}

		slog.Info("–ü—Ä–æ–≤–µ—Ä–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏", slog.String("Token", tokenStr))

		claims, err := s.validateAccessToken(r.Context(), tokenStr)
		if err != nil {
			slog.WarnContext(r.Context(), "—Ç–æ–∫–µ–Ω –Ω–µ –ø—Ä–æ—à—ë–ª –≤–∞–ª–∏–¥–∞—Ü–∏—é", slog.String("token", tokenStr), slog.String("error", err.Error()))
			s.JSON(w, r, http.StatusUnauthorized, "—Ç–æ–∫–µ–Ω –Ω–µ –ø—Ä–æ—à—ë–ª –≤–∞–ª–∏–¥–∞—Ü–∏—é", "error")
			return
		}

		key := "access_hash:" + tokenStr
		if _, err := s.Redis.Get(r.Context(), key).Result(); err == redis.Nil {
			s.JSON(w, r, http.StatusUnauthorized, "token revoked or expired", "error")
			return
		}

		ctx := context.WithValue(r.Context(), "user", claims)
		next.ServeHTTP(w, r.WithContext(ctx))
	})
}

func (s *Server) MiddlewareRequestID(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		rid := r.Header.Get("X-Request-ID")
		if rid == "" {
			rid = xid.New().String()
		}

		ctx := context.WithValue(r.Context(), requestIDKey, rid)

		w.Header().Set("X-Request-ID", rid)

		next.ServeHTTP(w, r.WithContext(ctx))
	})
}

// === Utils functions ===

// JSON - —Ñ–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç –æ—Ç–≤–µ—Ç –≤ JSON –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –µ–≥–æ –∫–ª–∏–µ–Ω—Ç—É
func (s *Server) JSON(w http.ResponseWriter, r *http.Request, status int, payload any, respType string) {
	options := responseOptions{
		respType:  respType,
		requestID: extractRequestID(r),
	}

	success := status >= 200 && status < 300

	resp := api.ApiResponse{
		RequestID: &options.requestID,
		Status:    &status,
		Success:   &success,
		Data:      &map[string]interface{}{respType: payload},
	}

	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(status)

	if err := json.NewEncoder(w).Encode(resp); err != nil {
		slog.Error("json encode failed after headers written",
			slog.Int("status", status),
			slog.String("error", err.Error()),
			slog.String("request_id", options.requestID),
		)
	}
}

func (s *Server) validateAccessToken(ctx context.Context, tokenStr string) (*Claims, error) {
	claims := &Claims{}

	token, err := jwt.ParseWithClaims(tokenStr, claims, func(token *jwt.Token) (interface{}, error) {
		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
			slog.WarnContext(ctx, "–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º", "alg", token.Header["alg"])
			return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
		}
		return s.JwtKey, nil
	})

	if err != nil {
		return nil, fmt.Errorf("token parse error: %w", err)
	}

	if !token.Valid {
		return nil, errors.New("invalid token")
	}

	if token.Header["alg"] != "HS256" {
		return nil, errors.New("only HS256 allowed")
	}

	redisKey := "access_hash:" + tokenStr
	if _, err = s.Redis.Get(ctx, redisKey).Result(); err != nil {
		slog.ErrorContext(ctx, "redis error during token validation", "err", err)
		return nil, fmt.Errorf("redis error: %w", err)
	}

	if claims.TokenID == "" {
		return nil, errors.New("missing token_id (jti)")
	}

	if claims.ID == uuid.Nil {
		return nil, errors.New("missing user id in claims")
	}

	return claims, nil
}

// === Private functions ===

func extractToken(r *http.Request) string {
	if r == nil {
		return ""
	}

	if v := r.Context().Value(tokenKey); v != nil {
		if token, ok := v.(string); ok {
			return token
		}
	}

	return ""
}

// extractRequestID - –∏–∑–≤–ª–µ–∫–∞–µ—Ç –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –∑–∞–ø—Ä–æ—Å–∞ –∏–∑ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –∏–ª–∏ –∑–∞–≥–æ–ª–æ–≤–∫–∞ X-Request-ID
func extractRequestID(r *http.Request) string {
	if r == nil {
		return ""
	}

	if v := r.Context().Value(requestIDKey); v != nil {
		if id, ok := v.(string); ok {
			return id
		}
	}

	return ""
}
